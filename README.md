# Домашнее задание №4 - трекинг объектов
## Метод tracker_soft

Трекинг объектов происходит по центроиду их боксов (bounding_box). Для быстрого и точного поиска совпадений используется евклидово расстояние между центроидами объектов. Это позволяет избежать ошибок, связанных с движением объектов на большие расстояния между кадрами и с пропаданием некоторых объектов (отсутствие детекции), что было бы сложным для методов, основанных на Intersection Over Union (IoU). Использование евклидова расстояния также помогает эффективно работать в случае, если объекты быстро перемещаются по сцене.

Каждый кадр обрабатывается отдельно, и для объектов с боксами находится наилучший трек из истории. Поиск осуществляется с использованием евклидова расстояния между центроидами текущих объектов и треков, которые еще не были использованы. Если подходящий трек найден, объект получает соответствующий track_id, и этот идентификатор удаляется из истории, чтобы избежать его повторного использования.

Если подходящий трек не найден, это означает, что либо объект новый, либо переместился на значительное расстояние (которое больше трешхолда). В этом случае создается новый track_id, который добавляется в историю треков.

В задании было сказано обязательно менять track_id, поэтому постарались предусмотреть такую возможность для объектов без боксо - для объектов, для которых не удалось найти bounding_box, используется принцип временного выживания (TTL — time-to-live). Объектам без детекций, которые не перемещаются по кадрам, присваиваются уже существующие треки с максимальным временем жизни, что позволяет уменьшить вероятность появления ложных совпадений. Выбираются треки с максимальным временем жизни, потому что считается, что они более стабильны и этот объект появился недавно.

[Пример работы](https://drive.google.com/file/d/1LVov9K9lbrnro_7QcBmmjrP0XixUd8P8/view?usp=sharing)
## Метод tracker_strong

Сначала для каждого объекта извлекаются эмбеддинги из его бокса (bounding_box) с помощью модели MobileNet. Эти эмбеддинги позволяют улучшить сопоставление объектов, даже если они изменяют положение или масштаб, или если происходит частичное перекрытие объектов.

При наличии детекции объектов на кадре происходит обновление треков с помощью алгоритма DeepSORT. Треки сопоставляются с детекциями на основе эмбеддингов и ID объектов, что позволяет отслеживать объекты в условиях перекрытий и перемещений.

Для объектов без bounding_box, аналогично методу tracker_soft, используется принцип времени жизни (TTL). Треки с максимальным TTL считаются наиболее стабильными, так как они, как правило, только что появились, и их продолжительность жизни позволяет избежать ложных совпадений, поэтому они и ассоциируются с новыми объектами без детекций.

[Пример работы](https://drive.google.com/file/d/1GVhHXXRHKJcF7Ryt71S8H-XuCRIA-gjZ/view?usp=sharing)
# Сравнение результатов
Для сранвения трекеров использовались метрики:
-  `ID Precision` - точность соответствия track_id реальному cb_id. Показывает, насколько точно отслеживаемый объект совпадает с его реальной меткой. Чем выше, тем лучше.
- `ID Switch `Count` - количество переключений track_id между объектами. Показывает количество раз, когда один объект в кадре был отслежен разными идентификаторами. Чем меньше, тем лучше
- `Mismatch Ratio` - измеряет количество ошибок (несоответствий) при привязке трека к объекту в кадре. Рассчитывается как $$\frac{количество ~переключений}{количество ~детекций}$$ Чем меньше, тем лучше.

Для сравнения трекеры были протестированы с диапазоном значений:
- `track_count` = [5, 10, 20]
- `random_range` = [2, 5]
- `bb_skip_percent` = [0.2, 0.4]

Расчет метрик реализован в файле `metrics.py`.

## Подготовка к тестированию
Необходимые треки были сгенерированы с помощью скрипта `generate_tracks.py`. В нем с разными аргументами вызвается скрипт `create_track_w_args.py` - модифицированная версия скрипта `create_track.py`. Результаты записываются в файл с соответсвуующим названием: `./obj{track_count}/obj{track_count}_{random_range}_{bb_skip_percent}.py`

Для метода tracker_strong были сохранены фреймы для каждой комбинации параметров. Для сохранения фреймов использовался закомментированный метод в конце файла `fastapi_server.py`. Фрйемы сохранялись в папку с соответсвующим названием: `./obj{track_count}/obj{track_count}_{random_range}_{bb_skip_percent}/`
### tracker_soft

| Объекты | random_range | bb_skip_percent | Average Track Coverage | ID Switch Count | Mismatch Ratio |
|:-------:|:------------:|:---------------:|:------------:|:---------------:|:--------------:|
|   5     |      2       |       0.2       |   0.69948    |       96        |     0.59627    |
|   5     |      2       |       0.4       |   0.62778    |      112        |     1.02752    |
|   5     |      5       |       0.2       |   0.62147    |       94        |     0.69630    |
|   5     |      5       |       0.4       |   0.56051    |       83        |     0.90217    |
|  10     |      2       |       0.2       |   0.50000    |      177        |     0.67045    |
|  10     |      2       |       0.4       |   0.49838    |      217        |     1.11856    |
|  10     |      5       |       0.2       |   0.54341    |      185        |     0.72835    |
|  10     |      5       |       0.4       |   0.50565    |      261        |     1.24880    |
|  20     |      2       |       0.2       |   0.45882    |      498        |     0.79680    |
|  20     |      2       |       0.4       |   0.36684    |      592        |     1.32438    |
|  20     |      5       |       0.2       |   0.39484    |      495        |     0.85492    |
|  20     |      5       |       0.4       |   0.38005    |      563        |     1.23465    |

Видим, что с ростом количества объектов на фрейме качество трекинга ухудшается. Также бОльшая вероятность пропуска детекции негативно влияет на трекинг - количество переключений возрастает.
### tracker_strong


| Объекты | random_range | bb_skip_percent | Average Track Coverage | ID Switch Count | Mismatch Ratio |
|:-------:|:------------:|:---------------:|:------------:|:---------------:|:--------------:|
|   5     |      2       |       0.2       |   0.72021    |       74        |     0.45963    |
|   5     |      2       |       0.4       |   0.66111    |      120        |     1.10092    |
|   5     |      5       |       0.2       |   0.71751    |       79        |     0.58519    |
|   5     |      5       |       0.4       |   0.65605    |       98        |     1.06522    |
|  10     |      2       |       0.2       |   0.62202    |      164        |     0.62121    |
|  10     |      2       |       0.4       |   0.49515    |      206        |     1.06186    |
|  10     |      5       |       0.2       |   0.56592    |      142        |     0.55906    |
|  10     |      5       |       0.4       |   0.49718    |      232        |     1.11005    |
|  20     |      2       |       0.2       |   0.58170    |      356        |     0.56960    |
|  20     |      2       |       0.4       |   0.46084    |      562        |     1.25727    |
| 20      | 5            | 0.2             | 0.62143      | 352             | 0.60794        |
| 20      | 5            | 0.4             | 0.39353      | 542             | 1.188596       |

Видим, что `tracker_strong` в среднем работает лучше, чем `tracker_soft`. Особенно это заметно при большем количестве объектов на фрейме: при 20 объектах значения `Average Track Coverage` у `tracker_strong` выше, чем у `tracker_soft`, а `Mismatch Ratio` и `ID Switch Count` — ниже. Это говорит о большей устойчивости трекера в сложных сценах. Однако при некоторых комбинациях параметров (например, 10 объектов, `random_range = 5`, `bb_skip_percent = 0.4`) количество переключений (ID Switch) у `tracker_strong` может быть выше, чем у `tracker_soft`, но при этом `Average Track Coverage` остаётся выше — это может свидетельствовать о том, что трекер лучше удерживает ключевые треки, даже если чаще происходит переключение ID у других треков - возможно без детекций.

Как и в случае с `tracker_soft`, пропуски детекций существенно снижают метрики: при переходе с `bb_skip_percent = 0.2` на `0.4` наблюдается резкое увеличение `Mismatch Ratio` и снижение `Average Track Coverage`. Несмотря на это, `tracker_strong` демонстрирует более стабильное поведение.

Падение `Average Track Coverage` и рост `ID Switch Count` могут говорить о нехватке контекстной информации в трекинге при плотных сценах. Возможно проблему может решить более тонкая настройка параметров
